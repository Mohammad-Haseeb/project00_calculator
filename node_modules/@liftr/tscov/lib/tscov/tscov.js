"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tscov = void 0;
const tslib_1 = require("tslib");
const minimist_1 = tslib_1.__importDefault(require("minimist"));
const path = tslib_1.__importStar(require("path"));
const kleur_1 = require("kleur");
const check_types_1 = require("./check-types");
const min_coverage_1 = require("./min-coverage");
const logger_util_1 = require("../tscov/utils/logger.util");
async function tscov() {
    let suppressError = false;
    try {
        executeTscov()
            .then(success => {
            logger_util_1.showSpacesLog();
            if (!success && !suppressError) {
                process.exit(1);
            }
        })
            .catch((err) => console.error(err));
    }
    catch (error) {
        logger_util_1.showDefaultError(error, suppressError);
    }
    // tslint:disable-next-line:cognitive-complexity no-big-function
    async function executeTscov() {
        logger_util_1.showTitleAndBanner();
        const argv = minimist_1.default(process.argv.slice(2), { '--': true });
        suppressError = argv.suppressError;
        const showVersion = argv.v || argv.version;
        if (showVersion) {
            return logger_util_1.showToolVersion();
        }
        const showHelp = argv.h || argv.help;
        if (showHelp) {
            return logger_util_1.showHelpLog();
        }
        let projectInput = argv.p || argv.project;
        const fileInput = argv.f || argv.file;
        if (projectInput === undefined && argv._.length === 0) {
            projectInput = '.';
        }
        if (projectInput === undefined && fileInput === undefined && !showHelp && !showVersion) {
            return logger_util_1.showCommandError();
        }
        const { correctCount, totalCount, anys } = await check_types_1.startLinter(projectInput, true, argv.debug, fileInput);
        const openCount = totalCount - correctCount;
        const percentage = Math.round(10000 * correctCount / totalCount) / 100;
        const minCoverage = await min_coverage_1.getMinCoverage(argv) || 90;
        const failed = minCoverage && percentage < minCoverage;
        const success = minCoverage && percentage > minCoverage;
        if (argv.d || argv.details || failed) {
            logger_util_1.showUncoveredTypesIntro();
            for (const { file, line, character, text } of anys) {
                console.log(`${path.resolve(process.cwd(), file)}: ` + kleur_1.cyan(`${line + 1}:${character + 1}`) + ` - ${text}`);
            }
        }
        logger_util_1.showCoverageResult(totalCount, correctCount, openCount);
        if (success)
            logger_util_1.showSuccess(percentage);
        if (failed)
            logger_util_1.showFailedError(percentage, minCoverage);
        return !failed;
    }
}
exports.tscov = tscov;
